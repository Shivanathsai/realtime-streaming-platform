"""Event schemas and data models for the streaming platform."""

from datetime import datetime
from enum import Enum
from typing import Optional, Dict, Any
from pydantic import BaseModel, Field
import uuid
import orjson


class EventType(str, Enum):
    TRANSACTION = "transaction"
    LOGIN = "login"
    PAGE_VIEW = "page_view"
    CLICK = "click"
    API_CALL = "api_call"
    SENSOR_READING = "sensor_reading"


class AlertSeverity(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class RawEvent(BaseModel):
    """Base event ingested from producers."""
    event_id: str = Field(default_factory=lambda: uuid.uuid4().hex)
    event_type: EventType
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    user_id: str
    session_id: Optional[str] = None
    properties: Dict[str, Any] = Field(default_factory=dict)
    metadata: Dict[str, Any] = Field(default_factory=dict)

    def serialize(self) -> bytes:
        return orjson.dumps(self.model_dump(), default=str)

    @classmethod
    def deserialize(cls, data: bytes) -> "RawEvent":
        return cls.model_validate(orjson.loads(data))


class TransactionEvent(BaseModel):
    """Financial transaction event with enrichment fields."""
    event_id: str
    timestamp: datetime
    user_id: str
    amount: float
    currency: str = "USD"
    merchant_id: str
    merchant_category: str
    payment_method: str
    location_lat: Optional[float] = None
    location_lon: Optional[float] = None
    ip_address: Optional[str] = None
    device_id: Optional[str] = None
    is_international: bool = False

    # Enrichment fields (added by processor)
    user_avg_amount: Optional[float] = None
    user_txn_count_1h: Optional[int] = None
    user_txn_count_24h: Optional[int] = None
    velocity_score: Optional[float] = None
    amount_zscore: Optional[float] = None
    risk_score: Optional[float] = None

    def serialize(self) -> bytes:
        return orjson.dumps(self.model_dump(), default=str)

    @classmethod
    def deserialize(cls, data: bytes) -> "TransactionEvent":
        return cls.model_validate(orjson.loads(data))


class WindowAggregate(BaseModel):
    """Result of a windowed aggregation."""
    window_start: datetime
    window_end: datetime
    window_type: str  # tumbling, sliding, session
    group_key: str
    event_count: int = 0
    sum_amount: float = 0.0
    avg_amount: float = 0.0
    min_amount: float = 0.0
    max_amount: float = 0.0
    distinct_merchants: int = 0
    distinct_locations: int = 0

    def serialize(self) -> bytes:
        return orjson.dumps(self.model_dump(), default=str)


class Alert(BaseModel):
    """Alert generated by CEP pattern detection."""
    alert_id: str = Field(default_factory=lambda: uuid.uuid4().hex)
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    severity: AlertSeverity
    pattern_name: str
    user_id: str
    description: str
    trigger_events: list[str] = Field(default_factory=list)
    context: Dict[str, Any] = Field(default_factory=dict)

    def serialize(self) -> bytes:
        return orjson.dumps(self.model_dump(), default=str)

    @classmethod
    def deserialize(cls, data: bytes) -> "Alert":
        return cls.model_validate(orjson.loads(data))


class ProcessorState(BaseModel):
    """Stateful processor checkpoint."""
    user_id: str
    event_buffer: list[Dict[str, Any]] = Field(default_factory=list)
    window_aggregates: Dict[str, Any] = Field(default_factory=dict)
    last_location: Optional[Dict[str, float]] = None
    last_event_time: Optional[datetime] = None
    running_sum: float = 0.0
    running_count: int = 0
    updated_at: datetime = Field(default_factory=datetime.utcnow)
